'use strict';

exports.__esModule = true;
exports.default = ignore;
exports.hasValidExtension = hasValidExtension;

var _path = require('path');

var _es6Set = require('es6-set');

var _es6Set2 = _interopRequireDefault(_es6Set);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// one-shot memoized
var cachedSet = void 0,
    lastSettings = void 0;
function validExtensions(_ref) {
  var settings = _ref.settings;

  if (cachedSet && settings === lastSettings) {
    return cachedSet;
  }

  // todo: add 'mjs'?
  lastSettings = settings;
  // breaking: default to '.js'
  // cachedSet = new Set(settings['import/extensions'] || [ '.js' ])
  cachedSet = 'import/extensions' in settings ? makeValidExtensionSet(settings) : { has: function has() {
      return true;
    } }; // the set of all elements

  return cachedSet;
}

function makeValidExtensionSet(settings) {
  // start with explicit JS-parsed extensions
  var exts = new _es6Set2.default(settings['import/extensions']);

  // all alternate parser extensions are also valid
  if ('import/parsers' in settings) {
    for (var parser in settings['import/parsers']) {
      settings['import/parsers'][parser].forEach(function (ext) {
        return exts.add(ext);
      });
    }
  }

  return exts;
}

function ignore(path, context) {
  // ignore node_modules by default
  var ignoreStrings = context.settings['import/ignore'] ? [].concat(context.settings['import/ignore']) : ['node_modules'];

  // check extension list first (cheap)
  if (!hasValidExtension(path, context)) return true;

  if (ignoreStrings.length === 0) return false;

  for (var i = 0; i < ignoreStrings.length; i++) {
    var regex = new RegExp(ignoreStrings[i]);
    if (regex.test(path)) return true;
  }

  return false;
}

function hasValidExtension(path, context) {
  return validExtensions(context).has((0, _path.extname)(path));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvcmUvaWdub3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztrQkFvQ3dCLE07UUFtQlIsaUIsR0FBQSxpQjs7QUF2RGhCOztBQUNBOzs7Ozs7QUFFQTtBQUNBLElBQUksa0JBQUo7QUFBQSxJQUFlLHFCQUFmO0FBQ0EsU0FBUyxlQUFULE9BQXVDO0FBQUEsTUFBWixRQUFZLFFBQVosUUFBWTs7QUFDckMsTUFBSSxhQUFhLGFBQWEsWUFBOUIsRUFBNEM7QUFDMUMsV0FBTyxTQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxpQkFBZSxRQUFmO0FBQ0E7QUFDQTtBQUNBLGNBQVksdUJBQXVCLFFBQXZCLEdBQ1Isc0JBQXNCLFFBQXRCLENBRFEsR0FFUixFQUFFLEtBQUs7QUFBQSxhQUFNLElBQU47QUFBQSxLQUFQLEVBRkosQ0FUcUMsQ0FXYjs7QUFFeEIsU0FBTyxTQUFQO0FBQ0Q7O0FBRUQsU0FBUyxxQkFBVCxDQUErQixRQUEvQixFQUF5QztBQUN2QztBQUNBLE1BQU0sT0FBTyxxQkFBUSxTQUFTLG1CQUFULENBQVIsQ0FBYjs7QUFFQTtBQUNBLE1BQUksb0JBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLFNBQUssSUFBSSxNQUFULElBQW1CLFNBQVMsZ0JBQVQsQ0FBbkIsRUFBK0M7QUFDN0MsZUFBUyxnQkFBVCxFQUEyQixNQUEzQixFQUNHLE9BREgsQ0FDVztBQUFBLGVBQU8sS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFQO0FBQUEsT0FEWDtBQUVEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7O0FBRWMsU0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXNCLE9BQXRCLEVBQStCO0FBQzVDO0FBQ0EsTUFBTSxnQkFBZ0IsUUFBUSxRQUFSLENBQWlCLGVBQWpCLElBQ2xCLEdBQUcsTUFBSCxDQUFVLFFBQVEsUUFBUixDQUFpQixlQUFqQixDQUFWLENBRGtCLEdBRWxCLENBQUMsY0FBRCxDQUZKOztBQUlBO0FBQ0EsTUFBSSxDQUFDLGtCQUFrQixJQUFsQixFQUF3QixPQUF4QixDQUFMLEVBQXVDLE9BQU8sSUFBUDs7QUFFdkMsTUFBSSxjQUFjLE1BQWQsS0FBeUIsQ0FBN0IsRUFBZ0MsT0FBTyxLQUFQOztBQUVoQyxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksY0FBYyxNQUFsQyxFQUEwQyxHQUExQyxFQUErQztBQUM3QyxRQUFJLFFBQVEsSUFBSSxNQUFKLENBQVcsY0FBYyxDQUFkLENBQVgsQ0FBWjtBQUNBLFFBQUksTUFBTSxJQUFOLENBQVcsSUFBWCxDQUFKLEVBQXNCLE9BQU8sSUFBUDtBQUN2Qjs7QUFFRCxTQUFPLEtBQVA7QUFDRDs7QUFFTSxTQUFTLGlCQUFULENBQTJCLElBQTNCLEVBQWlDLE9BQWpDLEVBQTBDO0FBQy9DLFNBQU8sZ0JBQWdCLE9BQWhCLEVBQXlCLEdBQXpCLENBQTZCLG1CQUFRLElBQVIsQ0FBN0IsQ0FBUDtBQUNEIiwiZmlsZSI6ImNvcmUvaWdub3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXh0bmFtZSB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgU2V0IGZyb20gJ2VzNi1zZXQnXG5cbi8vIG9uZS1zaG90IG1lbW9pemVkXG5sZXQgY2FjaGVkU2V0LCBsYXN0U2V0dGluZ3NcbmZ1bmN0aW9uIHZhbGlkRXh0ZW5zaW9ucyh7IHNldHRpbmdzIH0pIHtcbiAgaWYgKGNhY2hlZFNldCAmJiBzZXR0aW5ncyA9PT0gbGFzdFNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGNhY2hlZFNldFxuICB9XG5cbiAgLy8gdG9kbzogYWRkICdtanMnP1xuICBsYXN0U2V0dGluZ3MgPSBzZXR0aW5nc1xuICAvLyBicmVha2luZzogZGVmYXVsdCB0byAnLmpzJ1xuICAvLyBjYWNoZWRTZXQgPSBuZXcgU2V0KHNldHRpbmdzWydpbXBvcnQvZXh0ZW5zaW9ucyddIHx8IFsgJy5qcycgXSlcbiAgY2FjaGVkU2V0ID0gJ2ltcG9ydC9leHRlbnNpb25zJyBpbiBzZXR0aW5nc1xuICAgID8gbWFrZVZhbGlkRXh0ZW5zaW9uU2V0KHNldHRpbmdzKVxuICAgIDogeyBoYXM6ICgpID0+IHRydWUgfSAvLyB0aGUgc2V0IG9mIGFsbCBlbGVtZW50c1xuXG4gIHJldHVybiBjYWNoZWRTZXRcbn1cblxuZnVuY3Rpb24gbWFrZVZhbGlkRXh0ZW5zaW9uU2V0KHNldHRpbmdzKSB7XG4gIC8vIHN0YXJ0IHdpdGggZXhwbGljaXQgSlMtcGFyc2VkIGV4dGVuc2lvbnNcbiAgY29uc3QgZXh0cyA9IG5ldyBTZXQoc2V0dGluZ3NbJ2ltcG9ydC9leHRlbnNpb25zJ10pXG5cbiAgLy8gYWxsIGFsdGVybmF0ZSBwYXJzZXIgZXh0ZW5zaW9ucyBhcmUgYWxzbyB2YWxpZFxuICBpZiAoJ2ltcG9ydC9wYXJzZXJzJyBpbiBzZXR0aW5ncykge1xuICAgIGZvciAobGV0IHBhcnNlciBpbiBzZXR0aW5nc1snaW1wb3J0L3BhcnNlcnMnXSkge1xuICAgICAgc2V0dGluZ3NbJ2ltcG9ydC9wYXJzZXJzJ11bcGFyc2VyXVxuICAgICAgICAuZm9yRWFjaChleHQgPT4gZXh0cy5hZGQoZXh0KSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXh0c1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpZ25vcmUocGF0aCwgY29udGV4dCkge1xuICAvLyBpZ25vcmUgbm9kZV9tb2R1bGVzIGJ5IGRlZmF1bHRcbiAgY29uc3QgaWdub3JlU3RyaW5ncyA9IGNvbnRleHQuc2V0dGluZ3NbJ2ltcG9ydC9pZ25vcmUnXVxuICAgID8gW10uY29uY2F0KGNvbnRleHQuc2V0dGluZ3NbJ2ltcG9ydC9pZ25vcmUnXSlcbiAgICA6IFsnbm9kZV9tb2R1bGVzJ11cblxuICAvLyBjaGVjayBleHRlbnNpb24gbGlzdCBmaXJzdCAoY2hlYXApXG4gIGlmICghaGFzVmFsaWRFeHRlbnNpb24ocGF0aCwgY29udGV4dCkpIHJldHVybiB0cnVlXG5cbiAgaWYgKGlnbm9yZVN0cmluZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGlnbm9yZVN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKGlnbm9yZVN0cmluZ3NbaV0pXG4gICAgaWYgKHJlZ2V4LnRlc3QocGF0aCkpIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1ZhbGlkRXh0ZW5zaW9uKHBhdGgsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHZhbGlkRXh0ZW5zaW9ucyhjb250ZXh0KS5oYXMoZXh0bmFtZShwYXRoKSlcbn1cbiJdfQ==