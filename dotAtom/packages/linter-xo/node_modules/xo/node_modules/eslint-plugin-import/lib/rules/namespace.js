'use strict';

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _getExports = require('../core/getExports');

var _getExports2 = _interopRequireDefault(_getExports);

var _importDeclaration = require('../importDeclaration');

var _importDeclaration2 = _interopRequireDefault(_importDeclaration);

var _declaredScope = require('../core/declaredScope');

var _declaredScope2 = _interopRequireDefault(_declaredScope);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.meta = {
  schema: [{
    'type': 'object',
    'properties': {
      'allowComputed': {
        'description': 'If `false`, will report computed (and thus, un-lintable) references ' + 'to namespace members.',
        'type': 'boolean',
        'default': false
      }
    },
    'additionalProperties': false
  }]
};

exports.create = function namespaceRule(context) {

  // read options
  var _ref = context.options[0] || {};

  var _ref$allowComputed = _ref.allowComputed;
  var allowComputed = _ref$allowComputed === undefined ? false : _ref$allowComputed;


  var namespaces = new _es6Map2.default();

  function makeMessage(last, namepath) {
    return '\'' + last.name + '\' not found in' + (namepath.length > 1 ? ' deeply ' : ' ') + ('imported namespace \'' + namepath.join('.') + '\'.');
  }

  return {

    // pick up all imports at body entry time, to properly respect hoisting
    'Program': function Program(_ref2) {
      var body = _ref2.body;

      function processBodyStatement(declaration) {
        if (declaration.type !== 'ImportDeclaration') return;

        if (declaration.specifiers.length === 0) return;

        var imports = _getExports2.default.get(declaration.source.value, context);
        if (imports == null) return null;

        if (imports.errors.length) {
          imports.reportErrors(context, declaration);
          return;
        }

        declaration.specifiers.forEach(function (specifier) {
          switch (specifier.type) {
            case 'ImportNamespaceSpecifier':
              if (!imports.size) {
                context.report(specifier, 'No exported names found in module \'' + declaration.source.value + '\'.');
              }
              namespaces.set(specifier.local.name, imports);
              break;
            case 'ImportDefaultSpecifier':
            case 'ImportSpecifier':
              {
                var meta = imports.get(
                // default to 'default' for default http://i.imgur.com/nj6qAWy.jpg
                specifier.imported ? specifier.imported.name : 'default');
                if (!meta || !meta.namespace) break;
                namespaces.set(specifier.local.name, meta.namespace);
                break;
              }
          }
        });
      }
      body.forEach(processBodyStatement);
    },

    // same as above, but does not add names to local map
    'ExportNamespaceSpecifier': function ExportNamespaceSpecifier(namespace) {
      var declaration = (0, _importDeclaration2.default)(context);

      var imports = _getExports2.default.get(declaration.source.value, context);
      if (imports == null) return null;

      if (imports.errors.length) {
        imports.reportErrors(context, declaration);
        return;
      }

      if (!imports.size) {
        context.report(namespace, 'No exported names found in module \'' + declaration.source.value + '\'.');
      }
    },

    // todo: check for possible redefinition

    'MemberExpression': function MemberExpression(dereference) {
      if (dereference.object.type !== 'Identifier') return;
      if (!namespaces.has(dereference.object.name)) return;

      if (dereference.parent.type === 'AssignmentExpression' && dereference.parent.left === dereference) {
        context.report(dereference.parent, 'Assignment to member of namespace \'' + dereference.object.name + '\'.');
      }

      // go deep
      var namespace = namespaces.get(dereference.object.name);
      var namepath = [dereference.object.name];
      // while property is namespace and parent is member expression, keep validating
      while (namespace instanceof _getExports2.default && dereference.type === 'MemberExpression') {

        if (dereference.computed) {
          if (!allowComputed) {
            context.report(dereference.property, 'Unable to validate computed reference to imported namespace \'' + dereference.object.name + '\'.');
          }
          return;
        }

        if (!namespace.has(dereference.property.name)) {
          context.report(dereference.property, makeMessage(dereference.property, namepath));
          break;
        }

        var exported = namespace.get(dereference.property.name);
        if (exported == null) return;

        // stash and pop
        namepath.push(dereference.property.name);
        namespace = exported.namespace;
        dereference = dereference.parent;
      }
    },

    'VariableDeclarator': function VariableDeclarator(_ref3) {
      var id = _ref3.id;
      var init = _ref3.init;

      if (init == null) return;
      if (init.type !== 'Identifier') return;
      if (!namespaces.has(init.name)) return;

      // check for redefinition in intermediate scopes
      if ((0, _declaredScope2.default)(context, init.name) !== 'module') return;

      // DFS traverse child namespaces
      function testKey(pattern, namespace) {
        var path = arguments.length <= 2 || arguments[2] === undefined ? [init.name] : arguments[2];

        if (!(namespace instanceof _getExports2.default)) return;

        if (pattern.type !== 'ObjectPattern') return;

        pattern.properties.forEach(function (property) {
          if (property.key.type !== 'Identifier') {
            context.report({
              node: property,
              message: 'Only destructure top-level names.'
            });
          } else if (!namespace.has(property.key.name)) {
            context.report({
              node: property,
              message: makeMessage(property.key, path)
            });
          } else {
            path.push(property.key.name);
            testKey(property.value, namespace.get(property.key.name).namespace, path);
            path.pop();
          }
        });
      }

      testKey(id, namespaces.get(init.name));
    }
  };
};
//# sourceMappingURL=data:application/json;base64,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QUFZLFNBQVMsR0FBckIsRUFBMEIsSUFBMUI7QUFGSSxhQUFmO0FBSUQsV0FMTSxNQUtBO0FBQ0wsaUJBQUssSUFBTCxDQUFVLFNBQVMsR0FBVCxDQUFhLElBQXZCO0FBQ0Esb0JBQVEsU0FBUyxLQUFqQixFQUF3QixVQUFVLEdBQVYsQ0FBYyxTQUFTLEdBQVQsQ0FBYSxJQUEzQixFQUFpQyxTQUF6RCxFQUFvRSxJQUFwRTtBQUNBLGlCQUFLLEdBQUw7QUFDRDtBQUNGLFNBaEJEO0FBaUJEOztBQUVELGNBQVEsRUFBUixFQUFZLFdBQVcsR0FBWCxDQUFlLEtBQUssSUFBcEIsQ0FBWjtBQUNEO0FBM0lJLEdBQVA7QUE2SUQsQ0E1SkQiLCJmaWxlIjoicnVsZXMvbmFtZXNwYWNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hcCBmcm9tICdlczYtbWFwJ1xuXG5pbXBvcnQgRXhwb3J0cyBmcm9tICcuLi9jb3JlL2dldEV4cG9ydHMnXG5pbXBvcnQgaW1wb3J0RGVjbGFyYXRpb24gZnJvbSAnLi4vaW1wb3J0RGVjbGFyYXRpb24nXG5pbXBvcnQgZGVjbGFyZWRTY29wZSBmcm9tICcuLi9jb3JlL2RlY2xhcmVkU2NvcGUnXG5cbmV4cG9ydHMubWV0YSA9IHtcbiAgc2NoZW1hOiBbXG4gICAge1xuICAgICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAnYWxsb3dDb21wdXRlZCc6IHtcbiAgICAgICAgICAnZGVzY3JpcHRpb24nOlxuICAgICAgICAgICAgJ0lmIGBmYWxzZWAsIHdpbGwgcmVwb3J0IGNvbXB1dGVkIChhbmQgdGh1cywgdW4tbGludGFibGUpIHJlZmVyZW5jZXMgJyArXG4gICAgICAgICAgICAndG8gbmFtZXNwYWNlIG1lbWJlcnMuJyxcbiAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IGZhbHNlLFxuICAgIH0sXG4gIF0sXG59XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gbmFtZXNwYWNlUnVsZShjb250ZXh0KSB7XG5cbiAgLy8gcmVhZCBvcHRpb25zXG4gIGNvbnN0IHtcbiAgICBhbGxvd0NvbXB1dGVkID0gZmFsc2UsXG4gIH0gPSBjb250ZXh0Lm9wdGlvbnNbMF0gfHwge31cblxuICBjb25zdCBuYW1lc3BhY2VzID0gbmV3IE1hcCgpXG5cbiAgZnVuY3Rpb24gbWFrZU1lc3NhZ2UobGFzdCwgbmFtZXBhdGgpIHtcbiAgICAgcmV0dXJuIGAnJHtsYXN0Lm5hbWV9JyBub3QgZm91bmQgaW5gICtcbiAgICAgICAgICAgIChuYW1lcGF0aC5sZW5ndGggPiAxID8gJyBkZWVwbHkgJyA6ICcgJykgK1xuICAgICAgICAgICAgYGltcG9ydGVkIG5hbWVzcGFjZSAnJHtuYW1lcGF0aC5qb2luKCcuJyl9Jy5gXG4gIH1cblxuICByZXR1cm4ge1xuXG4gICAgLy8gcGljayB1cCBhbGwgaW1wb3J0cyBhdCBib2R5IGVudHJ5IHRpbWUsIHRvIHByb3Blcmx5IHJlc3BlY3QgaG9pc3RpbmdcbiAgICAnUHJvZ3JhbSc6IGZ1bmN0aW9uICh7IGJvZHkgfSkge1xuICAgICAgZnVuY3Rpb24gcHJvY2Vzc0JvZHlTdGF0ZW1lbnQoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnR5cGUgIT09ICdJbXBvcnREZWNsYXJhdGlvbicpIHJldHVyblxuXG4gICAgICAgIGlmIChkZWNsYXJhdGlvbi5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgaW1wb3J0cyA9IEV4cG9ydHMuZ2V0KGRlY2xhcmF0aW9uLnNvdXJjZS52YWx1ZSwgY29udGV4dClcbiAgICAgICAgaWYgKGltcG9ydHMgPT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgICAgICBpZiAoaW1wb3J0cy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaW1wb3J0cy5yZXBvcnRFcnJvcnMoY29udGV4dCwgZGVjbGFyYXRpb24pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBkZWNsYXJhdGlvbi5zcGVjaWZpZXJzLmZvckVhY2goKHNwZWNpZmllcikgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcic6XG4gICAgICAgICAgICAgIGlmICghaW1wb3J0cy5zaXplKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5yZXBvcnQoc3BlY2lmaWVyLFxuICAgICAgICAgICAgICAgICAgYE5vIGV4cG9ydGVkIG5hbWVzIGZvdW5kIGluIG1vZHVsZSAnJHtkZWNsYXJhdGlvbi5zb3VyY2UudmFsdWV9Jy5gKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hbWVzcGFjZXMuc2V0KHNwZWNpZmllci5sb2NhbC5uYW1lLCBpbXBvcnRzKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcic6XG4gICAgICAgICAgICBjYXNlICdJbXBvcnRTcGVjaWZpZXInOiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBpbXBvcnRzLmdldChcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvICdkZWZhdWx0JyBmb3IgZGVmYXVsdCBodHRwOi8vaS5pbWd1ci5jb20vbmo2cUFXeS5qcGdcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPyBzcGVjaWZpZXIuaW1wb3J0ZWQubmFtZSA6ICdkZWZhdWx0JylcbiAgICAgICAgICAgICAgaWYgKCFtZXRhIHx8ICFtZXRhLm5hbWVzcGFjZSkgYnJlYWtcbiAgICAgICAgICAgICAgbmFtZXNwYWNlcy5zZXQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIG1ldGEubmFtZXNwYWNlKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGJvZHkuZm9yRWFjaChwcm9jZXNzQm9keVN0YXRlbWVudClcbiAgICB9LFxuXG4gICAgLy8gc2FtZSBhcyBhYm92ZSwgYnV0IGRvZXMgbm90IGFkZCBuYW1lcyB0byBsb2NhbCBtYXBcbiAgICAnRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyJzogZnVuY3Rpb24gKG5hbWVzcGFjZSkge1xuICAgICAgdmFyIGRlY2xhcmF0aW9uID0gaW1wb3J0RGVjbGFyYXRpb24oY29udGV4dClcblxuICAgICAgdmFyIGltcG9ydHMgPSBFeHBvcnRzLmdldChkZWNsYXJhdGlvbi5zb3VyY2UudmFsdWUsIGNvbnRleHQpXG4gICAgICBpZiAoaW1wb3J0cyA9PSBudWxsKSByZXR1cm4gbnVsbFxuXG4gICAgICBpZiAoaW1wb3J0cy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGltcG9ydHMucmVwb3J0RXJyb3JzKGNvbnRleHQsIGRlY2xhcmF0aW9uKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFpbXBvcnRzLnNpemUpIHtcbiAgICAgICAgY29udGV4dC5yZXBvcnQobmFtZXNwYWNlLFxuICAgICAgICAgIGBObyBleHBvcnRlZCBuYW1lcyBmb3VuZCBpbiBtb2R1bGUgJyR7ZGVjbGFyYXRpb24uc291cmNlLnZhbHVlfScuYClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gdG9kbzogY2hlY2sgZm9yIHBvc3NpYmxlIHJlZGVmaW5pdGlvblxuXG4gICAgJ01lbWJlckV4cHJlc3Npb24nOiBmdW5jdGlvbiAoZGVyZWZlcmVuY2UpIHtcbiAgICAgIGlmIChkZXJlZmVyZW5jZS5vYmplY3QudHlwZSAhPT0gJ0lkZW50aWZpZXInKSByZXR1cm5cbiAgICAgIGlmICghbmFtZXNwYWNlcy5oYXMoZGVyZWZlcmVuY2Uub2JqZWN0Lm5hbWUpKSByZXR1cm5cblxuICAgICAgaWYgKGRlcmVmZXJlbmNlLnBhcmVudC50eXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nICYmXG4gICAgICAgICAgZGVyZWZlcmVuY2UucGFyZW50LmxlZnQgPT09IGRlcmVmZXJlbmNlKSB7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnQoZGVyZWZlcmVuY2UucGFyZW50LFxuICAgICAgICAgICAgICBgQXNzaWdubWVudCB0byBtZW1iZXIgb2YgbmFtZXNwYWNlICcke2RlcmVmZXJlbmNlLm9iamVjdC5uYW1lfScuYClcbiAgICAgIH1cblxuICAgICAgLy8gZ28gZGVlcFxuICAgICAgdmFyIG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuZ2V0KGRlcmVmZXJlbmNlLm9iamVjdC5uYW1lKVxuICAgICAgdmFyIG5hbWVwYXRoID0gW2RlcmVmZXJlbmNlLm9iamVjdC5uYW1lXVxuICAgICAgLy8gd2hpbGUgcHJvcGVydHkgaXMgbmFtZXNwYWNlIGFuZCBwYXJlbnQgaXMgbWVtYmVyIGV4cHJlc3Npb24sIGtlZXAgdmFsaWRhdGluZ1xuICAgICAgd2hpbGUgKG5hbWVzcGFjZSBpbnN0YW5jZW9mIEV4cG9ydHMgJiZcbiAgICAgICAgICAgICBkZXJlZmVyZW5jZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcblxuICAgICAgICBpZiAoZGVyZWZlcmVuY2UuY29tcHV0ZWQpIHtcbiAgICAgICAgICBpZiAoIWFsbG93Q29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVwb3J0KGRlcmVmZXJlbmNlLnByb3BlcnR5LFxuICAgICAgICAgICAgICAnVW5hYmxlIHRvIHZhbGlkYXRlIGNvbXB1dGVkIHJlZmVyZW5jZSB0byBpbXBvcnRlZCBuYW1lc3BhY2UgXFwnJyArXG4gICAgICAgICAgICAgIGRlcmVmZXJlbmNlLm9iamVjdC5uYW1lICsgJ1xcJy4nKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmFtZXNwYWNlLmhhcyhkZXJlZmVyZW5jZS5wcm9wZXJ0eS5uYW1lKSkge1xuICAgICAgICAgIGNvbnRleHQucmVwb3J0KFxuICAgICAgICAgICAgZGVyZWZlcmVuY2UucHJvcGVydHksXG4gICAgICAgICAgICBtYWtlTWVzc2FnZShkZXJlZmVyZW5jZS5wcm9wZXJ0eSwgbmFtZXBhdGgpKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHBvcnRlZCA9IG5hbWVzcGFjZS5nZXQoZGVyZWZlcmVuY2UucHJvcGVydHkubmFtZSlcbiAgICAgICAgaWYgKGV4cG9ydGVkID09IG51bGwpIHJldHVyblxuXG4gICAgICAgIC8vIHN0YXNoIGFuZCBwb3BcbiAgICAgICAgbmFtZXBhdGgucHVzaChkZXJlZmVyZW5jZS5wcm9wZXJ0eS5uYW1lKVxuICAgICAgICBuYW1lc3BhY2UgPSBleHBvcnRlZC5uYW1lc3BhY2VcbiAgICAgICAgZGVyZWZlcmVuY2UgPSBkZXJlZmVyZW5jZS5wYXJlbnRcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAnVmFyaWFibGVEZWNsYXJhdG9yJzogZnVuY3Rpb24gKHsgaWQsIGluaXQgfSkge1xuICAgICAgaWYgKGluaXQgPT0gbnVsbCkgcmV0dXJuXG4gICAgICBpZiAoaW5pdC50eXBlICE9PSAnSWRlbnRpZmllcicpIHJldHVyblxuICAgICAgaWYgKCFuYW1lc3BhY2VzLmhhcyhpbml0Lm5hbWUpKSByZXR1cm5cblxuICAgICAgLy8gY2hlY2sgZm9yIHJlZGVmaW5pdGlvbiBpbiBpbnRlcm1lZGlhdGUgc2NvcGVzXG4gICAgICBpZiAoZGVjbGFyZWRTY29wZShjb250ZXh0LCBpbml0Lm5hbWUpICE9PSAnbW9kdWxlJykgcmV0dXJuXG5cbiAgICAgIC8vIERGUyB0cmF2ZXJzZSBjaGlsZCBuYW1lc3BhY2VzXG4gICAgICBmdW5jdGlvbiB0ZXN0S2V5KHBhdHRlcm4sIG5hbWVzcGFjZSwgcGF0aCA9IFtpbml0Lm5hbWVdKSB7XG4gICAgICAgIGlmICghKG5hbWVzcGFjZSBpbnN0YW5jZW9mIEV4cG9ydHMpKSByZXR1cm5cblxuICAgICAgICBpZiAocGF0dGVybi50eXBlICE9PSAnT2JqZWN0UGF0dGVybicpIHJldHVyblxuXG4gICAgICAgIHBhdHRlcm4ucHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlcG9ydCh7XG4gICAgICAgICAgICAgIG5vZGU6IHByb3BlcnR5LFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnT25seSBkZXN0cnVjdHVyZSB0b3AtbGV2ZWwgbmFtZXMuJyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIGlmICghbmFtZXNwYWNlLmhhcyhwcm9wZXJ0eS5rZXkubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgICAgICAgbm9kZTogcHJvcGVydHksXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IG1ha2VNZXNzYWdlKHByb3BlcnR5LmtleSwgcGF0aCksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gocHJvcGVydHkua2V5Lm5hbWUpXG4gICAgICAgICAgICB0ZXN0S2V5KHByb3BlcnR5LnZhbHVlLCBuYW1lc3BhY2UuZ2V0KHByb3BlcnR5LmtleS5uYW1lKS5uYW1lc3BhY2UsIHBhdGgpXG4gICAgICAgICAgICBwYXRoLnBvcCgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICB0ZXN0S2V5KGlkLCBuYW1lc3BhY2VzLmdldChpbml0Lm5hbWUpKVxuICAgIH0sXG4gIH1cbn1cbiJdfQ==